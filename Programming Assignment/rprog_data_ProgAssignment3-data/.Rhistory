print("hello world")
r<c(1,1)
r<-c(1,1)
r
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(i) inv <<- i
getinverse <- function() inv
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
m <- makeCacheMatrix(matrix(c(1,2,3,4),nrow=2,byrow=FALSE))
m$get(0)
m$get()
m$getinverse()
getInv <- function() i
## The following functions are used to cache the inverse of a matrix.
## This helps avoid recalculating the inverse multiple times, which can
## be computationally expensive if the matrix is large.
## makeCacheMatrix creates a special "matrix" object that can cache its inverse.
## It returns a list of four functions:
## 1. set()        -> sets the value of the matrix
## 2. get()        -> gets the value of the matrix
## 3. setinverse() -> caches the inverse of the matrix
## 4. getinverse() -> retrieves the cached inverse (if it exists)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setInv <- function(inverse) i <<- inverse
getInv <- function() i
list(set = set, get = get, setInv = setInv, getInv = getInv)
}
## cacheSolve computes the inverse of the special "matrix" returned by makeCacheMatrix.
## If the inverse has already been calculated and cached, it retrieves it directly.
## Otherwise, it computes the inverse using solve(), stores it in the cache,
## and returns the computed inverse.
cacheSolve <- function(x, ...) {
i <- x$getInv()
if (!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setInv(i)
i
}
m <- makeCacheMatrix(matrix(c(1,2,3,4),nrow=2,byrow=TRUE))
m
m$get()
m$getInv()
cacheSolve(m)
m$getInv()
m$set(matrix(c(3,4,5,6),nrow=2,byrow=FALSE)
)
m$getInv()
cacheSolve(m)
cacheSolve(m)
set.seed(1)
rpois(5,2)
dnorm(0)
pnorm(1.96)
qnorm(0.975)
rnorm(5)
dpois(2, lambda=3)
ppois(2, lambda=3)
dpois(2,lamda = 3)
dpois(2,lambda = 3)
ppois(2,lamda=3)
ppois(2,lambda=3)
rpois(5, lambda=3)
dbinom(2,size=10,prob=0.5)
dbinom(2, size=10, prob=0.5)
pbinom(2, size=10, prob=0.5)
qbinom(0.95, size=10, prob=0.5)
rbinom(5,size=10,prob=0.5)
dbinom(2,size=10,prob=0.5)
pbinom(2,size=10, prob =0.5)
set.seed(10)
x <- rep(0:1,each=5)
x
e <- rnorm(10,0,20)
e
?rnorm
y<-0.5+2*x+e
y
y
y
data.frame(x, y)
library(datasets)
Rprof()
fit <- lm(y~x1+x2)
setwd("C:/Users/DELL/OneDrive/Desktop/R Programming/Programming Assignment/rprog_data_ProgAssignment3-data")
outcome <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
head(outcome)
ncol(outcome)
nrow(outcome)
outcome[,11]<-as.numeric(outcome[,11])
hist(outcome[, 11])
best<-function(state,outcome){}
source("best.R")
best("TX", "heart attack")
best("TX", "heart failure")
best("MD", "heart attack")
best("MD", "pneumonia")
best("BB", "heart attack")
best("NY", "hert attack")
source("rankhospital.R")
head(rankall("heart attack", 20), 10)
head(rankhospital("heart attack", 20), 10)
rankhospital("MD", "heart failure", 5)
source("rankhospital.R")
head(rankhospital("heart attack", 20), 10)
tail(rankall("pneumonia", "worst"), 3)
head(rankall("heart attack", 20), 10)
source("rankhospital.R")
rankhospital("TX", "heart failure", 4)
rankhospital("MD", "heart attack", "worst")
source("best.R")
best("SC", "heart attack")
best("NY", "pneumonia")
best("AK", "pneumonia")
rankhospital("NC", "heart attack", "worst")
rankhospital("WA", "heart attack", 7)
rankhospital("TX", "pneumonia", 10)
rankhospital("NY", "heart attack", 7)
r <- rankall("heart attack", 4)
as.character(subset(r, state == "HI")$hospital)
r <- rankall("pneumonia", "worst")
as.character(subset(r, state == "NJ")$hospital)
r <- rankall("heart failure", 10)
as.character(subset(r, state == "NV")$hospital)
